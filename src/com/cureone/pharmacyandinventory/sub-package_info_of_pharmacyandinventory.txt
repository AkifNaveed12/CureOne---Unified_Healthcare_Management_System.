Pharmacy & Inventory Module (com.cureone.pharmacyinventory)
---------------------------------------------------------
Purpose
-------
This module handles all pharmacy-related functionality: medicine catalog, inventory tracking, categories, and stock management. It allows adding/updating medicines, tracking inventory items, generating simple stock reports, and supporting other modules (e.g., billing) by exposing service methods.

Sub-packages & Responsibilities
-------------------------------
1) model
   - Stores entity classes (plain data objects) that represent domain objects.
   - Classes: Medicine, InventoryItem, Category.
   - Typical fields: id, name, price, quantity/stock, categoryId.
   - Responsibilities: data holders with constructors, getters, setters and toString().

2) repository
   - Single responsibility: persist and retrieve domain objects.
   - Interfaces used so implementations can use arrays or file storage.
   - Classes: MedicineRepository, InventoryRepository.
   - Typical methods:
     - save(entity)
     - findAll()
     - findById(id)
     - update(entity)
     - delete(id)

3) service
   - Business logic layer. Validates data, enforces business rules (e.g., no negative stock), and coordinates repository calls.
   - Classes: MedicineService, InventoryService.
   - Typical methods:
     - addMedicine(Medicine)
     - listMedicines()
     - getMedicineById(id)
     - updateMedicine(Medicine)
     - removeMedicine(id)
     - addItem(InventoryItem) / listItems() / updateItem() / removeItem(id)
   - Return types can be void, domain objects, lists, or Result<T> for success/error messages.

4) controller
   - Interface layer for user interactions (console or future UI). Calls services and renders or prints results.
   - Classes: MedicineController, InventoryController.
   - Typical methods:
     - addMedicine(Medicine), listMedicines(), updateMedicine(Medicine), deleteMedicine(id)
     - addItem(InventoryItem), listItems(), updateItem(InventoryItem), deleteItem(id)
   - Controllers should not contain business logic; they only collect input and call services.

Classes & Key Members (summary)
-------------------------------
- Medicine
  - Fields: int id, String name, double price, int quantity
  - Purpose: represent a medicine record.

- InventoryItem
  - Fields: int id, String itemName, int stock
  - Purpose: represent non-medicine inventory (consumables) with stock counts.

- Category
  - Fields: int id, String name
  - Purpose: group medicines into categories (e.g., analgesics, antibiotics).

- MedicineRepository (interface)
  - Methods: save, findAll, findById, update, delete
  - Purpose: abstract data storage for medicines.

- InventoryRepository (interface)
  - Methods: save, findAll, findById, update, delete
  - Purpose: abstract data storage for inventory items.

- MedicineService
  - Methods: addMedicine, listMedicines, getMedicineById, updateMedicine, removeMedicine
  - Purpose: implement medicine-specific business rules (e.g., validate price/quantity).

- InventoryService
  - Methods: addItem, listItems, getItemById, updateItem, removeItem
  - Purpose: handle inventory logic like restocking thresholds.

- MedicineController / InventoryController
  - Methods: UI-facing wrappers for performing operations using services.


Workflow Overview
Controller → gets input from the user
Service → processes the data, validates it, and applies business logic
Repository → stores or retrieves data from arrays/files
Model → represents the actual data objects

Example Flow:
User adds a medicine via MedicineController → MedicineService validates and processes → MedicineRepository saves it → Medicine object represents the medicine.

Workflow Diagram (Data Flow)
User Input
│
▼
Controller (com.cureone.controller)
│
▼
Service (com.cureone.service)
│
▼
Repository (com.cureone.repository)
│
▼
Model Objects (com.cureone.model)

Flow Explanation:
Controller receives user input (e.g., add a new medicine).
Service validates input, applies business rules (e.g., check stock limits).
Repository saves or retrieves data (arrays or text files).
Model stores the data in objects representing real-world entities.
Result is returned back through Service → Controller → User.


Notes & Implementation Tips
---------------------------
- Keep repositories as the only layer that reads/writes data (to arrays/files).
- Services should return Result<T> or domain objects and never perform I/O directly.
- Controllers should be minimal and handle input/output only.
- Use small, frequent commits when adding entities or repository implementations so reviewers can follow progress.
