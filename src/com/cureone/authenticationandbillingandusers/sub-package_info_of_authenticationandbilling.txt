Users, Authentication & Billing Module (com.cureone.users)
---------------------------------------------------------
Purpose
-------
This module handles user accounts, authentication, roles/permissions, and basic billing/invoicing for services and pharmacy purchases. It also exposes user management functions used by admins and reporting features.

Sub-packages & Responsibilities
-------------------------------
1) model
   - Domain objects for users, roles, and invoices.
   - Classes: User, Role, Invoice.
   - Typical fields:
     - User: id, username, password, role
     - Role: name, description
     - Invoice: invoiceId, patientId, amount, date

2) repository
   - Data access for users and billing records.
   - Classes: UserRepository, BillingRepository (interfaces).
   - Typical methods: save, findAll, findById, findByUsername, update, delete

3) service
   - Business operations for authentication and billing.
   - Classes: UserService, BillingService.
   - Typical methods:
     - UserService: login(username, password), registerUser(User), getUserById(id), listUsers(), changePassword(userId, newPassword)
     - BillingService: createInvoice(Invoice), getInvoiceById(id), listInvoices()

4) controller
   - UI-facing user and billing operations.
   - Classes: UserController, BillingController.
   - Typical methods:
     - login(username, password), register(User), listUsers()
     - createInvoice(Invoice), listInvoices()

Classes & Key Members (summary)
-------------------------------
- User
  - Fields: int id, String username, String password, String role
  - Purpose: represent system user accounts (admins, staff).

- Role
  - Fields: String name, String description
  - Purpose: capture simple role metadata; used for authorization checks later.

- Invoice
  - Fields: int invoiceId, int patientId, double amount, String date
  - Purpose: represent bill records for services or pharmacy purchases.

- UserRepository (interface)
  - Methods: save, findAll, findById, findByUsername, update, delete
  - Purpose: store and lookup users (login needs findByUsername).

- BillingRepository (interface)
  - Methods: save, findAll, findById, update, delete
  - Purpose: store invoices and billing records.

- UserService
  - Methods: login, registerUser, getUserById, listUsers, changePassword
  - Purpose: perform authentication checks (simple match for skeleton); in future, hash passwords and add sessions.

- BillingService
  - Methods: createInvoice, getInvoiceById, listInvoices
  - Purpose: assemble charges, persist invoices, and provide data for reports.


Workflow Overview
Controller → gets input from the user
Service → processes the data, validates it, and applies business logic
Repository → stores or retrieves data from arrays/files
Model → represents the actual data objects

Example Flow:
User adds a medicine via MedicineController → MedicineService validates and processes → MedicineRepository saves it → Medicine object represents the medicine.

Workflow Diagram (Data Flow)
User Input
│
▼
Controller (com.cureone.controller)
│
▼
Service (com.cureone.service)
│
▼
Repository (com.cureone.repository)
│
▼
Model Objects (com.cureone.model)

Flow Explanation:
Controller receives user input (e.g., add a new medicine).
Service validates input, applies business rules (e.g., check stock limits).
Repository saves or retrieves data (arrays or text files).
Model stores the data in objects representing real-world entities.
Result is returned back through Service → Controller → User.


Notes & Implementation Tips
---------------------------
- For skeletons, login can be a simple username/password check; do NOT store plain passwords in production—use hashing later.
- UserService should expose findByUsername so other modules (e.g., controllers for auditing) can validate users.
- BillingService may reference repository methods and may be called by pharmacy or appointment services when finalizing charges.
- Keep sensitive logic (password hashing, token generation) for later phases; skeletons only need clear method signatures.
